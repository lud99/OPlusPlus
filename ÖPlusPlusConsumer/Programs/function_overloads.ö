/*let f(x: int) {
	return 2;
}
let f(x: int, y: string):double  {

	return 6677;
}

let f(x: double) {
	return 2;
}

let f(x: string) {
	return 2;
}

f(5);*/

// example of return type overload
let makeError(message: int) : void {
	return;
}
let makeError(message : int) : int {
	return 0;
}
let makeError(message : string) : int {
	return 0;
}
let makeError(message : string) : double {
	return 0;
}
let makeError(message: double) : double {
	return 0;
}

let doStuff():double {
	//...
	return makeError(2);

	// enum A = ::B
	// Animal a = { "Bosse" }.Get(); (expected type is always the variable type)
	// string b = { "Bosse" }.Name(); (wont work { "bosse" } is expected to be a string, but string doesnt have .Name())
}

// wont work as there is no expected type so function cannot be resolved
let doStuff() {
	//...
	//return makeError(3);
}

// ex 2 with class with multiple datatypes (union)
/*class Value {
	let intValue : int;
	let boolValue : bool;
	let doubleValue : double;

	let getValue() :int { return intValue; };
	let getValue() :bool { return boolValue; };
	let getValue() :double { return doubleValue; };
};*/
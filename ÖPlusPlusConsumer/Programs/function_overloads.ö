/*let f(x: int) {
	return 2;
}
let f(x: int, y: string):double  {

	return 6677;
}

let f(x: double) {
	return 2;
}

let f(x: string) {
	return 2;
}

f(5);*/

// example of return type overload
let makeError(message: int) : int {
	return 0;
}
let makeError(message : int) : int {
	return 0;
}
let makeError(message : string) : int {
	return 0;
}
let makeError(message : string) : double {
	return 0;
}
let makeError(message: double) : string {
	return "";
}

let doStuff():double {
	//...
	return makeError(2);
}

// wont work as there is no expected type so function cannot be resolved
let doStuff() {
	//...
	//return makeError(3);
}

// ex 2 with class with multiple datatypes (union)
/*class Value {
	let intValue : int;
	let boolValue : bool;
	let doubleValue : double;

	let getValue() :int { return intValue; };
	let getValue() :bool { return boolValue; };
	let getValue() :double { return doubleValue; };
};*/